{"ast":null,"code":"// const BlobToImage = (props) => {\n//   const { byteArray } = props;\n//   let images = [];\n\n//   //Check if blobData is null or undefined\n//   if (byteArray === null || byteArray === undefined) {\n//     return null;\n//   }\n\n//   if (Array.isArray(byteArray)) {\n//     images = byteArray.map((byteData, index) => {\n//       const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\n//       const imageUrl = URL.createObjectURL(blob);\n\n//       // return <img key={index} src={imageUrl} alt={`Image ${index}`} />;   \n//       return { original: imageUrl, thumbnail: imageUrl, height: img.naturalHeight };    \n//     });\n//   } else {\n//     const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\n//     const imageUrl = URL.createObjectURL(blob);\n//     //images.push(<img key={0} src={imageUrl} alt=\"Image\" />);\n\n//     // Use an Image object to get the natural height\n//     const img = new Image();\n//     img.src = imageUrl;\n\n//     images.push({\n//       original: imageUrl,\n//       thumbnail: imageUrl,\n//       height: img.naturalHeight\n//     });\n//   }  \n//   return images;\n// }\n\n// export default BlobToImage;\n\nconst BlobToImage = async props => {\n  const {\n    byteArray\n  } = props;\n  let images = [];\n\n  // Check if byteArray is null or undefined\n  if (byteArray === null || byteArray === undefined) {\n    return null;\n  }\n  const createImageObject = async blob => {\n    const imageUrl = URL.createObjectURL(blob);\n\n    // Use an Image object to get the natural height\n    const img = new Image();\n\n    // Create a promise that resolves when the image is loaded\n    const imageLoaded = new Promise(resolve => {\n      img.onload = () => resolve();\n    });\n    img.src = imageUrl;\n\n    // Wait for the image to load\n    await imageLoaded;\n    const imageObject = {\n      original: imageUrl,\n      thumbnail: imageUrl,\n      height: img.naturalHeight // Get the natural height of the image\n    };\n\n    // Detach event handlers to allow garbage collection\n    img.onload = null;\n    img.onerror = null;\n    return imageObject;\n  };\n  if (Array.isArray(byteArray)) {\n    const imagePromises = byteArray.map(byteData => {\n      const blob = new Blob([new Uint8Array(byteData)], {\n        type: 'image/jpeg'\n      });\n      return createImageObject(blob);\n    });\n    images = await Promise.all(imagePromises);\n  } else {\n    const blob = new Blob([new Uint8Array(byteArray)], {\n      type: 'image/jpeg'\n    });\n    images.push(await createImageObject(blob));\n  }\n  return images;\n};\n_c = BlobToImage;\nexport default BlobToImage;\nvar _c;\n$RefreshReg$(_c, \"BlobToImage\");","map":{"version":3,"names":["BlobToImage","props","byteArray","images","undefined","createImageObject","blob","imageUrl","URL","createObjectURL","img","Image","imageLoaded","Promise","resolve","onload","src","imageObject","original","thumbnail","height","naturalHeight","onerror","Array","isArray","imagePromises","map","byteData","Blob","Uint8Array","type","all","push","_c","$RefreshReg$"],"sources":["D:/Glenn McKnight/Documents/Github/SocialDynamo/SocialDynamo/Frontend/react-frontend/src/util/blob-to-image.js"],"sourcesContent":["// const BlobToImage = (props) => {\r\n//   const { byteArray } = props;\r\n//   let images = [];\r\n\r\n//   //Check if blobData is null or undefined\r\n//   if (byteArray === null || byteArray === undefined) {\r\n//     return null;\r\n//   }\r\n\r\n//   if (Array.isArray(byteArray)) {\r\n//     images = byteArray.map((byteData, index) => {\r\n//       const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\r\n//       const imageUrl = URL.createObjectURL(blob);\r\n\r\n//       // return <img key={index} src={imageUrl} alt={`Image ${index}`} />;   \r\n//       return { original: imageUrl, thumbnail: imageUrl, height: img.naturalHeight };    \r\n//     });\r\n//   } else {\r\n//     const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\r\n//     const imageUrl = URL.createObjectURL(blob);\r\n//     //images.push(<img key={0} src={imageUrl} alt=\"Image\" />);\r\n\r\n//     // Use an Image object to get the natural height\r\n//     const img = new Image();\r\n//     img.src = imageUrl;\r\n\r\n//     images.push({\r\n//       original: imageUrl,\r\n//       thumbnail: imageUrl,\r\n//       height: img.naturalHeight\r\n//     });\r\n//   }  \r\n//   return images;\r\n// }\r\n\r\n// export default BlobToImage;\r\n\r\nconst BlobToImage = async (props) => {\r\n  const { byteArray } = props;\r\n  let images = [];\r\n\r\n  // Check if byteArray is null or undefined\r\n  if (byteArray === null || byteArray === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const createImageObject = async (blob) => {\r\n    const imageUrl = URL.createObjectURL(blob);\r\n\r\n    // Use an Image object to get the natural height\r\n    const img = new Image();\r\n\r\n    // Create a promise that resolves when the image is loaded\r\n    const imageLoaded = new Promise((resolve) => {\r\n      img.onload = () => resolve();\r\n    });\r\n\r\n    img.src = imageUrl;\r\n\r\n    // Wait for the image to load\r\n    await imageLoaded;\r\n\r\n    const imageObject = {\r\n      original: imageUrl,\r\n      thumbnail: imageUrl,\r\n      height: img.naturalHeight, // Get the natural height of the image\r\n    };\r\n\r\n    // Detach event handlers to allow garbage collection\r\n    img.onload = null;\r\n    img.onerror = null;\r\n\r\n    return imageObject;\r\n  };\r\n\r\n  if (Array.isArray(byteArray)) {\r\n    const imagePromises = byteArray.map((byteData) => {\r\n      const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\r\n      return createImageObject(blob);\r\n    });\r\n\r\n    images = await Promise.all(imagePromises);\r\n  } else {\r\n    const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\r\n    images.push(await createImageObject(blob));\r\n  }\r\n\r\n  return images;\r\n};\r\n\r\nexport default BlobToImage;\r\n\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAMA,WAAW,GAAG,MAAOC,KAAK,IAAK;EACnC,MAAM;IAAEC;EAAU,CAAC,GAAGD,KAAK;EAC3B,IAAIE,MAAM,GAAG,EAAE;;EAEf;EACA,IAAID,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAKE,SAAS,EAAE;IACjD,OAAO,IAAI;EACb;EAEA,MAAMC,iBAAiB,GAAG,MAAOC,IAAI,IAAK;IACxC,MAAMC,QAAQ,GAAGC,GAAG,CAACC,eAAe,CAACH,IAAI,CAAC;;IAE1C;IACA,MAAMI,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;;IAEvB;IACA,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAEC,OAAO,IAAK;MAC3CJ,GAAG,CAACK,MAAM,GAAG,MAAMD,OAAO,CAAC,CAAC;IAC9B,CAAC,CAAC;IAEFJ,GAAG,CAACM,GAAG,GAAGT,QAAQ;;IAElB;IACA,MAAMK,WAAW;IAEjB,MAAMK,WAAW,GAAG;MAClBC,QAAQ,EAAEX,QAAQ;MAClBY,SAAS,EAAEZ,QAAQ;MACnBa,MAAM,EAAEV,GAAG,CAACW,aAAa,CAAE;IAC7B,CAAC;;IAED;IACAX,GAAG,CAACK,MAAM,GAAG,IAAI;IACjBL,GAAG,CAACY,OAAO,GAAG,IAAI;IAElB,OAAOL,WAAW;EACpB,CAAC;EAED,IAAIM,KAAK,CAACC,OAAO,CAACtB,SAAS,CAAC,EAAE;IAC5B,MAAMuB,aAAa,GAAGvB,SAAS,CAACwB,GAAG,CAAEC,QAAQ,IAAK;MAChD,MAAMrB,IAAI,GAAG,IAAIsB,IAAI,CAAC,CAAC,IAAIC,UAAU,CAACF,QAAQ,CAAC,CAAC,EAAE;QAAEG,IAAI,EAAE;MAAa,CAAC,CAAC;MACzE,OAAOzB,iBAAiB,CAACC,IAAI,CAAC;IAChC,CAAC,CAAC;IAEFH,MAAM,GAAG,MAAMU,OAAO,CAACkB,GAAG,CAACN,aAAa,CAAC;EAC3C,CAAC,MAAM;IACL,MAAMnB,IAAI,GAAG,IAAIsB,IAAI,CAAC,CAAC,IAAIC,UAAU,CAAC3B,SAAS,CAAC,CAAC,EAAE;MAAE4B,IAAI,EAAE;IAAa,CAAC,CAAC;IAC1E3B,MAAM,CAAC6B,IAAI,CAAC,MAAM3B,iBAAiB,CAACC,IAAI,CAAC,CAAC;EAC5C;EAEA,OAAOH,MAAM;AACf,CAAC;AAAC8B,EAAA,GAnDIjC,WAAW;AAqDjB,eAAeA,WAAW;AAAC,IAAAiC,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}