{"ast":null,"code":"// const BlobToImage = (props) => {\n//   const { byteArray } = props;\n//   let images = [];\n\n//   //Check if blobData is null or undefined\n//   if (byteArray === null || byteArray === undefined) {\n//     return null;\n//   }\n\n//   if (Array.isArray(byteArray)) {\n//     images = byteArray.map((byteData, index) => {\n//       const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\n//       const imageUrl = URL.createObjectURL(blob);\n\n//       // return <img key={index} src={imageUrl} alt={`Image ${index}`} />;   \n//       return { original: imageUrl, thumbnail: imageUrl, height: img.naturalHeight };    \n//     });\n//   } else {\n//     const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\n//     const imageUrl = URL.createObjectURL(blob);\n//     //images.push(<img key={0} src={imageUrl} alt=\"Image\" />);\n\n//     // Use an Image object to get the natural height\n//     const img = new Image();\n//     img.src = imageUrl;\n\n//     images.push({\n//       original: imageUrl,\n//       thumbnail: imageUrl,\n//       height: img.naturalHeight\n//     });\n//   }  \n//   return images;\n// }\n\n// export default BlobToImage;\n\n// const BlobToImage = (props) => {\n//   const { byteArray } = props;\n\n//   console.log(\"In blobtoimage\");\n\n//   // Check if byteArray is null or undefined\n//   if (byteArray === null || byteArray === undefined) {\n//     return Promise.resolve([]);\n//   }\n\n//   const createImageObject = async (blob) => {\n//     const imageUrl = URL.createObjectURL(blob);\n\n//     console.log(\"In createImageObject in BlobToImage\");\n\n//     // Use an Image object to get the natural height\n//     const img = new Image();\n\n//     // Create a promise that resolves when the image is loaded\n//     const imageLoaded = new Promise((resolve) => {\n//       img.onload = () => resolve();\n//     });\n\n//     img.src = imageUrl;\n\n//     // Wait for the image to load\n//     await imageLoaded;\n\n//     const imageObject = {\n//       original: imageUrl,\n//       thumbnail: imageUrl,\n//       height: img.naturalHeight, // Get the natural height of the image\n//     };\n\n//     console.log(`In BobToImage, original: ${imageUrl}, height: ${img.naturalHeight}`);\n//     // // Detach event handlers to allow garbage collection\n//     // img.onload = null;\n//     // img.onerror = null;\n\n//     return imageObject;\n//   };\n\n//   const processImages = async () => {\n\n//     console.log(\"In processImages in BlobToImage\");\n\n//     if (Array.isArray(byteArray)) {\n//       const imagePromises = byteArray.map((byteData) => {\n//         const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\n//         return createImageObject(blob);\n//       });\n\n//       return Promise.all(imagePromises);\n//     } else {\n//       const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\n//       return [await createImageObject(blob)];\n//     }\n//   };\n\n//   return await processImages();\n// };\n\n// export default BlobToImage;\n\nconst BlobToImage = async props => {\n  const {\n    byteArray\n  } = props;\n\n  // Check if byteArray is null or undefined\n  if (byteArray === null || byteArray === undefined) {\n    return [];\n  }\n  const createImageObject = async blob => {\n    const imageUrl = URL.createObjectURL(blob);\n\n    // Use an Image object to get the natural height\n    const img = new Image();\n\n    // Create a promise that resolves when the image is loaded\n    const imageLoaded = new Promise(resolve => {\n      img.onload = () => resolve();\n    });\n    img.src = imageUrl;\n\n    // Wait for the image to load\n    await imageLoaded;\n    const imageObject = {\n      original: imageUrl,\n      thumbnail: imageUrl,\n      height: img.naturalHeight\n    };\n\n    // Detach event handlers to allow garbage collection\n    img.onload = null;\n    img.onerror = null;\n    return imageObject;\n  };\n  const processImages = async () => {\n    if (Array.isArray(byteArray)) {\n      const imagePromises = byteArray.map(byteData => {\n        const blob = new Blob([new Uint8Array(byteData)], {\n          type: 'image/jpeg'\n        });\n        return createImageObject(blob);\n      });\n      return await Promise.all(imagePromises);\n    } else {\n      const blob = new Blob([new Uint8Array(byteArray)], {\n        type: 'image/jpeg'\n      });\n      return [await createImageObject(blob)];\n    }\n  };\n  return await processImages();\n};\n_c = BlobToImage;\nexport default BlobToImage;\nvar _c;\n$RefreshReg$(_c, \"BlobToImage\");","map":{"version":3,"names":["BlobToImage","props","byteArray","undefined","createImageObject","blob","imageUrl","URL","createObjectURL","img","Image","imageLoaded","Promise","resolve","onload","src","imageObject","original","thumbnail","height","naturalHeight","onerror","processImages","Array","isArray","imagePromises","map","byteData","Blob","Uint8Array","type","all","_c","$RefreshReg$"],"sources":["D:/Glenn McKnight/Documents/Github/SocialDynamo/SocialDynamo/Frontend/react-frontend/src/util/blob-to-image.js"],"sourcesContent":["// const BlobToImage = (props) => {\r\n//   const { byteArray } = props;\r\n//   let images = [];\r\n\r\n//   //Check if blobData is null or undefined\r\n//   if (byteArray === null || byteArray === undefined) {\r\n//     return null;\r\n//   }\r\n\r\n//   if (Array.isArray(byteArray)) {\r\n//     images = byteArray.map((byteData, index) => {\r\n//       const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\r\n//       const imageUrl = URL.createObjectURL(blob);\r\n\r\n//       // return <img key={index} src={imageUrl} alt={`Image ${index}`} />;   \r\n//       return { original: imageUrl, thumbnail: imageUrl, height: img.naturalHeight };    \r\n//     });\r\n//   } else {\r\n//     const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\r\n//     const imageUrl = URL.createObjectURL(blob);\r\n//     //images.push(<img key={0} src={imageUrl} alt=\"Image\" />);\r\n\r\n//     // Use an Image object to get the natural height\r\n//     const img = new Image();\r\n//     img.src = imageUrl;\r\n\r\n//     images.push({\r\n//       original: imageUrl,\r\n//       thumbnail: imageUrl,\r\n//       height: img.naturalHeight\r\n//     });\r\n//   }  \r\n//   return images;\r\n// }\r\n\r\n// export default BlobToImage;\r\n\r\n// const BlobToImage = (props) => {\r\n//   const { byteArray } = props;\r\n\r\n\r\n\r\n//   console.log(\"In blobtoimage\");\r\n\r\n\r\n\r\n//   // Check if byteArray is null or undefined\r\n//   if (byteArray === null || byteArray === undefined) {\r\n//     return Promise.resolve([]);\r\n//   }\r\n\r\n//   const createImageObject = async (blob) => {\r\n//     const imageUrl = URL.createObjectURL(blob);\r\n\r\n\r\n\r\n//     console.log(\"In createImageObject in BlobToImage\");\r\n\r\n\r\n\r\n\r\n//     // Use an Image object to get the natural height\r\n//     const img = new Image();\r\n\r\n//     // Create a promise that resolves when the image is loaded\r\n//     const imageLoaded = new Promise((resolve) => {\r\n//       img.onload = () => resolve();\r\n//     });\r\n\r\n//     img.src = imageUrl;\r\n\r\n//     // Wait for the image to load\r\n//     await imageLoaded;\r\n\r\n//     const imageObject = {\r\n//       original: imageUrl,\r\n//       thumbnail: imageUrl,\r\n//       height: img.naturalHeight, // Get the natural height of the image\r\n//     };\r\n\r\n\r\n\r\n\r\n\r\n//     console.log(`In BobToImage, original: ${imageUrl}, height: ${img.naturalHeight}`);\r\n//     // // Detach event handlers to allow garbage collection\r\n//     // img.onload = null;\r\n//     // img.onerror = null;\r\n\r\n\r\n\r\n\r\n\r\n\r\n//     return imageObject;\r\n//   };\r\n\r\n//   const processImages = async () => {\r\n\r\n\r\n\r\n//     console.log(\"In processImages in BlobToImage\");\r\n\r\n\r\n\r\n\r\n//     if (Array.isArray(byteArray)) {\r\n//       const imagePromises = byteArray.map((byteData) => {\r\n//         const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\r\n//         return createImageObject(blob);\r\n//       });\r\n\r\n//       return Promise.all(imagePromises);\r\n//     } else {\r\n//       const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\r\n//       return [await createImageObject(blob)];\r\n//     }\r\n//   };\r\n\r\n//   return await processImages();\r\n// };\r\n\r\n// export default BlobToImage;\r\n\r\n\r\n\r\n\r\n\r\nconst BlobToImage = async (props) => {\r\n  const { byteArray } = props;\r\n\r\n  // Check if byteArray is null or undefined\r\n  if (byteArray === null || byteArray === undefined) {\r\n    return [];\r\n  }\r\n\r\n  const createImageObject = async (blob) => {\r\n    const imageUrl = URL.createObjectURL(blob);\r\n\r\n    // Use an Image object to get the natural height\r\n    const img = new Image();\r\n\r\n    // Create a promise that resolves when the image is loaded\r\n    const imageLoaded = new Promise((resolve) => {\r\n      img.onload = () => resolve();\r\n    });\r\n\r\n    img.src = imageUrl;\r\n\r\n    // Wait for the image to load\r\n    await imageLoaded;\r\n\r\n    const imageObject = {\r\n      original: imageUrl,\r\n      thumbnail: imageUrl,\r\n      height: img.naturalHeight,\r\n    };\r\n\r\n    // Detach event handlers to allow garbage collection\r\n    img.onload = null;\r\n    img.onerror = null;\r\n\r\n    return imageObject;\r\n  };\r\n\r\n  const processImages = async () => {\r\n    if (Array.isArray(byteArray)) {\r\n      const imagePromises = byteArray.map((byteData) => {\r\n        const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\r\n        return createImageObject(blob);\r\n      });\r\n\r\n      return await Promise.all(imagePromises);\r\n    } else {\r\n      const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\r\n      return [await createImageObject(blob)];\r\n    }\r\n  };\r\n\r\n  return await processImages();\r\n};\r\n\r\nexport default BlobToImage;"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAIA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;AAIA;;AAKA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;;AAOA;AACA;;AAEA;;AAIA;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAMA,MAAMA,WAAW,GAAG,MAAOC,KAAK,IAAK;EACnC,MAAM;IAAEC;EAAU,CAAC,GAAGD,KAAK;;EAE3B;EACA,IAAIC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAKC,SAAS,EAAE;IACjD,OAAO,EAAE;EACX;EAEA,MAAMC,iBAAiB,GAAG,MAAOC,IAAI,IAAK;IACxC,MAAMC,QAAQ,GAAGC,GAAG,CAACC,eAAe,CAACH,IAAI,CAAC;;IAE1C;IACA,MAAMI,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;;IAEvB;IACA,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAEC,OAAO,IAAK;MAC3CJ,GAAG,CAACK,MAAM,GAAG,MAAMD,OAAO,CAAC,CAAC;IAC9B,CAAC,CAAC;IAEFJ,GAAG,CAACM,GAAG,GAAGT,QAAQ;;IAElB;IACA,MAAMK,WAAW;IAEjB,MAAMK,WAAW,GAAG;MAClBC,QAAQ,EAAEX,QAAQ;MAClBY,SAAS,EAAEZ,QAAQ;MACnBa,MAAM,EAAEV,GAAG,CAACW;IACd,CAAC;;IAED;IACAX,GAAG,CAACK,MAAM,GAAG,IAAI;IACjBL,GAAG,CAACY,OAAO,GAAG,IAAI;IAElB,OAAOL,WAAW;EACpB,CAAC;EAED,MAAMM,aAAa,GAAG,MAAAA,CAAA,KAAY;IAChC,IAAIC,KAAK,CAACC,OAAO,CAACtB,SAAS,CAAC,EAAE;MAC5B,MAAMuB,aAAa,GAAGvB,SAAS,CAACwB,GAAG,CAAEC,QAAQ,IAAK;QAChD,MAAMtB,IAAI,GAAG,IAAIuB,IAAI,CAAC,CAAC,IAAIC,UAAU,CAACF,QAAQ,CAAC,CAAC,EAAE;UAAEG,IAAI,EAAE;QAAa,CAAC,CAAC;QACzE,OAAO1B,iBAAiB,CAACC,IAAI,CAAC;MAChC,CAAC,CAAC;MAEF,OAAO,MAAMO,OAAO,CAACmB,GAAG,CAACN,aAAa,CAAC;IACzC,CAAC,MAAM;MACL,MAAMpB,IAAI,GAAG,IAAIuB,IAAI,CAAC,CAAC,IAAIC,UAAU,CAAC3B,SAAS,CAAC,CAAC,EAAE;QAAE4B,IAAI,EAAE;MAAa,CAAC,CAAC;MAC1E,OAAO,CAAC,MAAM1B,iBAAiB,CAACC,IAAI,CAAC,CAAC;IACxC;EACF,CAAC;EAED,OAAO,MAAMiB,aAAa,CAAC,CAAC;AAC9B,CAAC;AAACU,EAAA,GApDIhC,WAAW;AAsDjB,eAAeA,WAAW;AAAC,IAAAgC,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}