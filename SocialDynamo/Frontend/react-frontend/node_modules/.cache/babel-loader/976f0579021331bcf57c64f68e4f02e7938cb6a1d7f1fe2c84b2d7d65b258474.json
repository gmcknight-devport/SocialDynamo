{"ast":null,"code":"// const BlobToImage = (props) => {\n//   const { byteArray } = props;\n//   let images = [];\n\n//   //Check if blobData is null or undefined\n//   if (byteArray === null || byteArray === undefined) {\n//     return null;\n//   }\n\n//   if (Array.isArray(byteArray)) {\n//     images = byteArray.map((byteData, index) => {\n//       const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\n//       const imageUrl = URL.createObjectURL(blob);\n\n//       // return <img key={index} src={imageUrl} alt={`Image ${index}`} />;   \n//       return { original: imageUrl, thumbnail: imageUrl, height: img.naturalHeight };    \n//     });\n//   } else {\n//     const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\n//     const imageUrl = URL.createObjectURL(blob);\n//     //images.push(<img key={0} src={imageUrl} alt=\"Image\" />);\n\n//     // Use an Image object to get the natural height\n//     const img = new Image();\n//     img.src = imageUrl;\n\n//     images.push({\n//       original: imageUrl,\n//       thumbnail: imageUrl,\n//       height: img.naturalHeight\n//     });\n//   }  \n//   return images;\n// }\n\n// export default BlobToImage;\n\nconst BlobToImage = props => {\n  const {\n    byteArray\n  } = props;\n\n  // Check if byteArray is null or undefined\n  if (byteArray === null || byteArray === undefined) {\n    return Promise.resolve([]);\n  }\n  const createImageObject = async blob => {\n    const imageUrl = URL.createObjectURL(blob);\n\n    // Use an Image object to get the natural height\n    const img = new Image();\n\n    // Create a promise that resolves when the image is loaded\n    const imageLoaded = new Promise(resolve => {\n      img.onload = () => resolve();\n    });\n    img.src = imageUrl;\n\n    // Wait for the image to load\n    await imageLoaded;\n    const imageObject = {\n      original: imageUrl,\n      thumbnail: imageUrl,\n      height: img.naturalHeight // Get the natural height of the image\n    };\n\n    console.log(`In BobToImage, original: ${imageUrl}, height: ${img.naturalHeight}`);\n    // // Detach event handlers to allow garbage collection\n    // img.onload = null;\n    // img.onerror = null;\n\n    return imageObject;\n  };\n  const processImages = async () => {\n    if (Array.isArray(byteArray)) {\n      const imagePromises = byteArray.map(byteData => {\n        const blob = new Blob([new Uint8Array(byteData)], {\n          type: 'image/jpeg'\n        });\n        return createImageObject(blob);\n      });\n      return Promise.all(imagePromises);\n    } else {\n      const blob = new Blob([new Uint8Array(byteArray)], {\n        type: 'image/jpeg'\n      });\n      return [await createImageObject(blob)];\n    }\n  };\n  return processImages();\n};\n_c = BlobToImage;\nexport default BlobToImage;\nvar _c;\n$RefreshReg$(_c, \"BlobToImage\");","map":{"version":3,"names":["BlobToImage","props","byteArray","undefined","Promise","resolve","createImageObject","blob","imageUrl","URL","createObjectURL","img","Image","imageLoaded","onload","src","imageObject","original","thumbnail","height","naturalHeight","console","log","processImages","Array","isArray","imagePromises","map","byteData","Blob","Uint8Array","type","all","_c","$RefreshReg$"],"sources":["D:/Glenn McKnight/Documents/Github/SocialDynamo/SocialDynamo/Frontend/react-frontend/src/util/blob-to-image.js"],"sourcesContent":["// const BlobToImage = (props) => {\r\n//   const { byteArray } = props;\r\n//   let images = [];\r\n\r\n//   //Check if blobData is null or undefined\r\n//   if (byteArray === null || byteArray === undefined) {\r\n//     return null;\r\n//   }\r\n\r\n//   if (Array.isArray(byteArray)) {\r\n//     images = byteArray.map((byteData, index) => {\r\n//       const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\r\n//       const imageUrl = URL.createObjectURL(blob);\r\n\r\n//       // return <img key={index} src={imageUrl} alt={`Image ${index}`} />;   \r\n//       return { original: imageUrl, thumbnail: imageUrl, height: img.naturalHeight };    \r\n//     });\r\n//   } else {\r\n//     const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\r\n//     const imageUrl = URL.createObjectURL(blob);\r\n//     //images.push(<img key={0} src={imageUrl} alt=\"Image\" />);\r\n\r\n//     // Use an Image object to get the natural height\r\n//     const img = new Image();\r\n//     img.src = imageUrl;\r\n\r\n//     images.push({\r\n//       original: imageUrl,\r\n//       thumbnail: imageUrl,\r\n//       height: img.naturalHeight\r\n//     });\r\n//   }  \r\n//   return images;\r\n// }\r\n\r\n// export default BlobToImage;\r\n\r\nconst BlobToImage = (props) => {\r\n  const { byteArray } = props;\r\n\r\n  // Check if byteArray is null or undefined\r\n  if (byteArray === null || byteArray === undefined) {\r\n    return Promise.resolve([]);\r\n  }\r\n\r\n  const createImageObject = async (blob) => {\r\n    const imageUrl = URL.createObjectURL(blob);\r\n\r\n    // Use an Image object to get the natural height\r\n    const img = new Image();\r\n\r\n    // Create a promise that resolves when the image is loaded\r\n    const imageLoaded = new Promise((resolve) => {\r\n      img.onload = () => resolve();\r\n    });\r\n\r\n    img.src = imageUrl;\r\n\r\n    // Wait for the image to load\r\n    await imageLoaded;\r\n\r\n    const imageObject = {\r\n      original: imageUrl,\r\n      thumbnail: imageUrl,\r\n      height: img.naturalHeight, // Get the natural height of the image\r\n    };\r\n\r\n\r\n\r\n\r\n    \r\n    console.log(`In BobToImage, original: ${imageUrl}, height: ${img.naturalHeight}`);\r\n    // // Detach event handlers to allow garbage collection\r\n    // img.onload = null;\r\n    // img.onerror = null;\r\n\r\n    return imageObject;\r\n  };\r\n\r\n  const processImages = async () => {\r\n    if (Array.isArray(byteArray)) {\r\n      const imagePromises = byteArray.map((byteData) => {\r\n        const blob = new Blob([new Uint8Array(byteData)], { type: 'image/jpeg' });\r\n        return createImageObject(blob);\r\n      });\r\n\r\n      return Promise.all(imagePromises);\r\n    } else {\r\n      const blob = new Blob([new Uint8Array(byteArray)], { type: 'image/jpeg' });\r\n      return [await createImageObject(blob)];\r\n    }\r\n  };\r\n\r\n  return processImages();\r\n};\r\n\r\nexport default BlobToImage;\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAMA,WAAW,GAAIC,KAAK,IAAK;EAC7B,MAAM;IAAEC;EAAU,CAAC,GAAGD,KAAK;;EAE3B;EACA,IAAIC,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAKC,SAAS,EAAE;IACjD,OAAOC,OAAO,CAACC,OAAO,CAAC,EAAE,CAAC;EAC5B;EAEA,MAAMC,iBAAiB,GAAG,MAAOC,IAAI,IAAK;IACxC,MAAMC,QAAQ,GAAGC,GAAG,CAACC,eAAe,CAACH,IAAI,CAAC;;IAE1C;IACA,MAAMI,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;;IAEvB;IACA,MAAMC,WAAW,GAAG,IAAIT,OAAO,CAAEC,OAAO,IAAK;MAC3CM,GAAG,CAACG,MAAM,GAAG,MAAMT,OAAO,CAAC,CAAC;IAC9B,CAAC,CAAC;IAEFM,GAAG,CAACI,GAAG,GAAGP,QAAQ;;IAElB;IACA,MAAMK,WAAW;IAEjB,MAAMG,WAAW,GAAG;MAClBC,QAAQ,EAAET,QAAQ;MAClBU,SAAS,EAAEV,QAAQ;MACnBW,MAAM,EAAER,GAAG,CAACS,aAAa,CAAE;IAC7B,CAAC;;IAMDC,OAAO,CAACC,GAAG,CAAE,4BAA2Bd,QAAS,aAAYG,GAAG,CAACS,aAAc,EAAC,CAAC;IACjF;IACA;IACA;;IAEA,OAAOJ,WAAW;EACpB,CAAC;EAED,MAAMO,aAAa,GAAG,MAAAA,CAAA,KAAY;IAChC,IAAIC,KAAK,CAACC,OAAO,CAACvB,SAAS,CAAC,EAAE;MAC5B,MAAMwB,aAAa,GAAGxB,SAAS,CAACyB,GAAG,CAAEC,QAAQ,IAAK;QAChD,MAAMrB,IAAI,GAAG,IAAIsB,IAAI,CAAC,CAAC,IAAIC,UAAU,CAACF,QAAQ,CAAC,CAAC,EAAE;UAAEG,IAAI,EAAE;QAAa,CAAC,CAAC;QACzE,OAAOzB,iBAAiB,CAACC,IAAI,CAAC;MAChC,CAAC,CAAC;MAEF,OAAOH,OAAO,CAAC4B,GAAG,CAACN,aAAa,CAAC;IACnC,CAAC,MAAM;MACL,MAAMnB,IAAI,GAAG,IAAIsB,IAAI,CAAC,CAAC,IAAIC,UAAU,CAAC5B,SAAS,CAAC,CAAC,EAAE;QAAE6B,IAAI,EAAE;MAAa,CAAC,CAAC;MAC1E,OAAO,CAAC,MAAMzB,iBAAiB,CAACC,IAAI,CAAC,CAAC;IACxC;EACF,CAAC;EAED,OAAOgB,aAAa,CAAC,CAAC;AACxB,CAAC;AAACU,EAAA,GAzDIjC,WAAW;AA2DjB,eAAeA,WAAW;AAAC,IAAAiC,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}